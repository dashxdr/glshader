#ifdef GL_ES
precision mediump float;
#endif

// dashxdr 20140626
// This came from bubble writing used in ace_animpuzzle android app abortion
// https://play.google.com/store/apps/details?id=ace.animpuzzle
// QUESTION QUESTION QUESTION QUESTION
// Where does everyone hang out to talk about shaders + glshadersandbox?

const vec3 COLOR = vec3(1.0, 0.0, 0.0);
const vec3 COLOR2 = vec3(1.0, 1.0, 1.0);
const vec3 LIGHTPOS = vec3(-10.5, 10.0, 10.0);
const float AMBIENT = .3;
const float TSCALE = 5.0;
const float RF = 10.0;

varying vec2 surfacePosition;
uniform float time;

vec3 best;
vec2 pos;

void closest_point(vec2 origin, vec2 unitx, float low, float high, float k)
{
// find closest point on parabola

	vec2 unity = vec2(-unitx.y, unitx);
	vec2 oc = pos - origin;
	vec2 at;
	at.x = dot(oc, unitx);
	at.y = dot(oc, unity);

	float mid;
	for(int c=0;c<9;++c)
	{
		mid = (low + high) * .5;
		float kmid = k * mid;
		vec2 dir = vec2(1.0, 2.0 * kmid); // tangent at this point
		vec2 off = vec2(at.x - mid, at.y - mid * kmid); // offset to this pnt
		if(dot(dir, off)<0.0)
			high=mid;
		else
			low=mid;
	}
	float tx, ty;
	tx = mid;
	ty = k * tx * tx;
	vec2 center = origin + tx*unitx + ty*unity;
	float d = length(center-pos);
	if(d < best.z) // z used as distance
	{
		best.xy = center;
		best.z = d;
	}
}

void main()
{
	pos = surfacePosition;
	best = vec3(0.0, 0.0, 10000.0);

	int ch;
	pos = pos * 7.0 - .5;
	vec2 posi = floor(pos);
	pos = fract(pos) - .5;
	ch=int(mod(posi.x - posi.y*7.0+11., 26.));
	if(ch<26) ch += 65; // Ab

	if(ch==65) { // A
		closest_point(vec2(0.033, 0.329), vec2(-0.996, 0.087), -0.287, 0.000, 8.187);
		closest_point(vec2(0.033, 0.329), vec2(-0.996, 0.087), 0.000, 0.287, 8.187);
		closest_point(vec2(-0.323, 0.012), vec2(-0.297, -0.955), -0.124, -0.063, 33.184);
	}
	else if(ch==66) { // B
		closest_point(vec2(-0.118, 0.131), vec2(-0.143, 0.990), -0.433, 0.000, 1.018);
		closest_point(vec2(-0.118, 0.131), vec2(-0.143, 0.990), 0.000, 0.201, 1.018);
		closest_point(vec2(0.200, 0.318), vec2(-0.672, 0.740), -0.198, 0.000, 4.030);
		closest_point(vec2(0.200, 0.318), vec2(-0.672, 0.740), 0.000, 0.264, 4.030);
		closest_point(vec2(0.209, 0.054), vec2(0.563, 0.826), -0.211, 0.000, 4.998);
		closest_point(vec2(0.209, 0.054), vec2(0.563, 0.826), 0.000, 0.016, 4.998);
		closest_point(vec2(0.311, -0.259), vec2(0.397, 0.918), -0.280, 0.000, 6.176);
		closest_point(vec2(0.311, -0.259), vec2(0.397, 0.918), 0.000, 0.195, 6.176);
	}
	else if(ch==67) { // C
		closest_point(vec2(-0.137, 0.350), vec2(-0.854, -0.520), -0.288, 0.000, 2.927);
		closest_point(vec2(-0.137, 0.350), vec2(-0.854, -0.520), 0.000, 0.272, 2.927);
		closest_point(vec2(-0.124, -0.278), vec2(0.865, -0.502), -0.268, 0.000, 2.706);
		closest_point(vec2(-0.124, -0.278), vec2(0.865, -0.502), 0.000, 0.266, 2.706);
	}
	else if(ch==68) { // D
		closest_point(vec2(-0.114, -0.010), vec2(0.039, 0.999), -0.340, 0.000, 0.627);
		closest_point(vec2(-0.114, -0.010), vec2(0.039, 0.999), 0.000, 0.360, 0.627);
		closest_point(vec2(0.293, 0.282), vec2(-0.675, 0.738), -0.266, 0.000, 2.167);
		closest_point(vec2(0.293, 0.282), vec2(-0.675, 0.738), 0.000, 0.370, 2.167);
		closest_point(vec2(0.256, -0.245), vec2(0.709, 0.705), -0.396, 0.000, 1.600);
		closest_point(vec2(0.256, -0.245), vec2(0.709, 0.705), 0.000, 0.233, 1.600);
	}
	else if(ch==69) { // E
		closest_point(vec2(-0.067, 0.298), vec2(-0.854, -0.521), -0.248, 0.000, 2.205);
		closest_point(vec2(-0.067, 0.298), vec2(-0.854, -0.521), 0.000, 0.256, 2.205);
		closest_point(vec2(-0.163, -0.304), vec2(0.754, -0.657), -0.264, 0.000, 3.264);
		closest_point(vec2(-0.163, -0.304), vec2(0.754, -0.657), 0.000, 0.295, 3.264);
		closest_point(vec2(-0.198, 0.034), vec2(0.934, -0.356), -0.014, 0.000, 0.895);
		closest_point(vec2(-0.198, 0.034), vec2(0.934, -0.356), 0.000, 0.352, 0.895);
	}
	else if(ch==70) { // F
		closest_point(vec2(-0.095, 0.327), vec2(-0.789, -0.614), -0.263, 0.000, 3.324);
		closest_point(vec2(-0.095, 0.327), vec2(-0.789, -0.614), 0.000, 0.395, 3.324);
		closest_point(vec2(0.128, -0.000), vec2(0.998, -0.069), -0.300, 0.000, 0.779);
		closest_point(vec2(0.128, -0.000), vec2(0.998, -0.069), 0.000, 0.052, 0.779);
	}
	else if(ch==71) { // G
		closest_point(vec2(0.220, -0.115), vec2(-0.377, 0.926), -0.137, 0.000, 6.929);
		closest_point(vec2(0.220, -0.115), vec2(-0.377, 0.926), 0.000, 0.145, 6.929);
		closest_point(vec2(-0.072, -0.339), vec2(0.960, -0.278), -0.216, 0.000, 2.681);
		closest_point(vec2(-0.072, -0.339), vec2(0.960, -0.278), 0.000, 0.202, 2.681);
		closest_point(vec2(-0.259, 0.141), vec2(-0.418, -0.909), -0.212, 0.000, 1.949);
		closest_point(vec2(-0.259, 0.141), vec2(-0.418, -0.909), 0.000, 0.271, 1.949);
		closest_point(vec2(0.130, 0.317), vec2(-0.923, 0.385), -0.076, 0.000, 2.660);
		closest_point(vec2(0.130, 0.317), vec2(-0.923, 0.385), 0.000, 0.199, 2.660);
	}
	else if(ch==72) { // H
		closest_point(vec2(-0.219, 0.369), vec2(-0.279, 0.960), -0.682, -0.060, 0.445);
		closest_point(vec2(0.183, -0.355), vec2(0.376, -0.926), -0.626, -0.010, 0.727);
		closest_point(vec2(0.108, -0.054), vec2(-0.937, 0.349), -0.020, 0.000, 0.691);
		closest_point(vec2(0.108, -0.054), vec2(-0.937, 0.349), 0.000, 0.278, 0.691);
	}
	else if(ch==73) { // I
		closest_point(vec2(-0.695, -1.731), vec2(0.911, 0.412), 1.217, 1.517, 0.681);
		closest_point(vec2(-0.296, -0.349), vec2(-0.925, -0.381), -0.417, -0.143, 0.985);
		closest_point(vec2(-0.474, 0.485), vec2(0.543, -0.840), 0.333, 0.498, 2.004);
	}
	else if(ch==74) { // J
		closest_point(vec2(0.101, -0.304), vec2(0.862, 0.508), -0.240, 0.000, 3.599);
		closest_point(vec2(0.101, -0.304), vec2(0.862, 0.508), 0.000, 0.382, 3.599);
	}
	else if(ch==75) { // K
		closest_point(vec2(-0.108, 0.244), vec2(-0.186, 0.983), -0.558, 0.000, 0.637);
		closest_point(vec2(-0.108, 0.244), vec2(-0.186, 0.983), 0.000, 0.097, 0.637);
		closest_point(vec2(0.113, 0.029), vec2(-0.910, 0.414), -0.288, 0.000, 3.404);
		closest_point(vec2(0.113, 0.029), vec2(-0.910, 0.414), 0.000, 0.164, 3.404);
		closest_point(vec2(0.429, 0.339), vec2(-0.992, 0.124), 0.118, 0.308, 3.591);
	}
	else if(ch==76) { // L
		closest_point(vec2(0.329, -0.424), vec2(-0.742, 0.670), 0.125, 0.403, 1.442);
		closest_point(vec2(-0.150, 0.361), vec2(-0.828, 0.560), -0.402, -0.085, 3.451);
	}
	else if(ch==77) { // M
		closest_point(vec2(-0.228, 0.243), vec2(-0.943, -0.333), -0.158, 0.000, 14.229);
		closest_point(vec2(-0.228, 0.243), vec2(-0.943, -0.333), 0.000, 0.193, 14.229);
		closest_point(vec2(0.279, 0.248), vec2(-0.948, 0.319), -0.167, 0.000, 19.914);
		closest_point(vec2(0.279, 0.248), vec2(-0.948, 0.319), 0.000, 0.132, 19.914);
	}
	else if(ch==78) { // N
		closest_point(vec2(-0.448, -0.692), vec2(0.665, 0.747), 0.417, 0.955, 0.506);
		closest_point(vec2(0.166, -1.060), vec2(0.999, -0.037), 0.021, 0.029, 1697.797);
		closest_point(vec2(0.632, -2.436), vec2(0.095, 0.995), 2.056, 2.676, 0.146);
	}
	else if(ch==79) { // O
		closest_point(vec2(-0.222, 0.186), vec2(-0.633, -0.774), -0.196, 0.000, 3.462);
		closest_point(vec2(-0.222, 0.186), vec2(-0.633, -0.774), 0.000, 0.222, 3.462);
		closest_point(vec2(-0.036, -0.269), vec2(0.998, -0.069), -0.208, 0.000, 3.777);
		closest_point(vec2(-0.036, -0.269), vec2(0.998, -0.069), 0.000, 0.209, 3.777);
		closest_point(vec2(0.209, 0.117), vec2(-0.417, 0.909), -0.203, 0.000, 2.920);
		closest_point(vec2(0.209, 0.117), vec2(-0.417, 0.909), 0.000, 0.208, 2.920);
	}
	else if(ch==80) { // P
		closest_point(vec2(-0.269, 0.808), vec2(-0.735, 0.678), -0.856, -0.444, 1.100);
		closest_point(vec2(0.329, 0.164), vec2(-0.304, 0.953), -0.098, 0.000, 3.793);
		closest_point(vec2(0.329, 0.164), vec2(-0.304, 0.953), 0.000, 0.301, 3.793);
		closest_point(vec2(0.184, -0.081), vec2(0.956, 0.292), -0.247, 0.000, 3.046);
		closest_point(vec2(0.184, -0.081), vec2(0.956, 0.292), 0.000, 0.174, 3.046);
	}
	else if(ch==81) { // Q
		closest_point(vec2(-0.251, 0.112), vec2(-0.319, -0.948), -0.288, 0.000, 2.931);
		closest_point(vec2(-0.251, 0.112), vec2(-0.319, -0.948), 0.000, 0.271, 2.931);
		closest_point(vec2(0.265, 0.207), vec2(-0.519, 0.855), -0.287, 0.000, 3.197);
		closest_point(vec2(0.265, 0.207), vec2(-0.519, 0.855), 0.000, 0.184, 3.197);
		closest_point(vec2(0.034, -0.260), vec2(0.993, 0.119), -0.162, 0.000, 2.578);
		closest_point(vec2(0.034, -0.260), vec2(0.993, 0.119), 0.000, 0.162, 2.578);
		closest_point(vec2(-0.352, 0.200), vec2(-0.772, -0.636), -0.177, -0.143, 24.743);
	}
	else if(ch==82) { // R
		closest_point(vec2(-0.319, 1.159), vec2(-0.836, 0.549), -0.896, -0.631, 1.454);
		closest_point(vec2(0.283, 0.187), vec2(-0.261, 0.965), -0.186, 0.000, 6.038);
		closest_point(vec2(0.283, 0.187), vec2(-0.261, 0.965), 0.000, 0.237, 6.038);
		closest_point(vec2(0.232, -0.263), vec2(-0.248, 0.969), -0.063, 0.000, 2.079);
		closest_point(vec2(0.232, -0.263), vec2(-0.248, 0.969), 0.000, 0.375, 2.079);
	}
	else if(ch==83) { // S
		closest_point(vec2(-0.191, 0.155), vec2(0.314, -0.950), -0.090, 0.000, 5.310);
		closest_point(vec2(-0.191, 0.155), vec2(0.314, -0.950), 0.000, 0.146, 5.310);
		closest_point(vec2(0.220, -0.309), vec2(0.702, 0.713), -0.262, 0.000, 3.547);
		closest_point(vec2(0.220, -0.309), vec2(0.702, 0.713), 0.000, 0.150, 3.547);
		closest_point(vec2(0.260, -0.116), vec2(-0.345, 0.939), -0.031, 0.000, 3.288);
		closest_point(vec2(0.260, -0.116), vec2(-0.345, 0.939), 0.000, 0.260, 3.288);
		closest_point(vec2(-0.122, 0.313), vec2(-0.828, -0.561), -0.309, 0.000, 2.775);
		closest_point(vec2(-0.122, 0.313), vec2(-0.828, -0.561), 0.000, 0.080, 2.775);
	}
	else if(ch==84) { // T
		closest_point(vec2(0.852, 0.017), vec2(-0.857, 0.514), 0.621, 1.019, 0.343);
		closest_point(vec2(0.035, 0.177), vec2(-0.033, 0.999), -0.519, 0.000, 0.357);
		closest_point(vec2(0.035, 0.177), vec2(-0.033, 0.999), 0.000, 0.064, 0.357);
	}
	else if(ch==85) { // U
		closest_point(vec2(-0.132, -0.234), vec2(0.773, -0.634), -0.371, 0.000, 2.560);
		closest_point(vec2(-0.132, -0.234), vec2(0.773, -0.634), 0.000, 0.138, 2.560);
		closest_point(vec2(0.131, -0.256), vec2(0.861, 0.508), -0.121, 0.000, 2.742);
		closest_point(vec2(0.131, -0.256), vec2(0.861, 0.508), 0.000, 0.363, 2.742);
	}
	else if(ch==86) { // V
		closest_point(vec2(0.027, -0.281), vec2(1.000, 0.032), -0.236, 0.000, 9.164);
		closest_point(vec2(0.027, -0.281), vec2(1.000, 0.032), 0.000, 0.235, 9.164);
	}
	else if(ch==87) { // W
		closest_point(vec2(-0.127, -0.243), vec2(1.000, 0.006), -0.172, 0.000, 16.134);
		closest_point(vec2(-0.127, -0.243), vec2(1.000, 0.006), 0.000, 0.152, 16.134);
		closest_point(vec2(0.156, -0.255), vec2(1.000, 0.001), -0.132, 0.000, 22.245);
		closest_point(vec2(0.156, -0.255), vec2(1.000, 0.001), 0.000, 0.154, 22.245);
	}
	else if(ch==88) { // X
		closest_point(vec2(0.051, -0.001), vec2(0.999, 0.034), -0.230, 0.000, 4.287);
		closest_point(vec2(0.051, -0.001), vec2(0.999, 0.034), 0.000, 0.231, 4.287);
		closest_point(vec2(0.056, -0.003), vec2(-0.998, 0.062), -0.239, 0.000, 5.591);
		closest_point(vec2(0.056, -0.003), vec2(-0.998, 0.062), 0.000, 0.244, 5.591);
	}
	else if(ch==89) { // Y
		closest_point(vec2(0.048, 0.035), vec2(1.000, 0.015), -0.195, 0.000, 5.747);
		closest_point(vec2(0.048, 0.035), vec2(1.000, 0.015), 0.000, 0.196, 5.747);
		closest_point(vec2(0.062, -0.058), vec2(-0.034, 0.999), -0.294, 0.000, 1.293);
		closest_point(vec2(0.062, -0.058), vec2(-0.034, 0.999), 0.000, 0.093, 1.293);
	}
	else if(ch==90) { // Z
		closest_point(vec2(0.292, 0.232), vec2(-0.306, 0.952), -0.187, 0.000, 10.227);
		closest_point(vec2(0.292, 0.232), vec2(-0.306, 0.952), 0.000, 0.217, 10.227);
		closest_point(vec2(-0.222, -0.285), vec2(0.335, -0.942), -0.140, 0.000, 15.172);
		closest_point(vec2(-0.222, -0.285), vec2(0.335, -0.942), 0.000, 0.178, 15.172);
	}

	vec3 pos3 = vec3(pos, 0.0);
	vec2 rad = pos3.xy - best.xy;
	float r = length(rad);
	float f = r * RF;
	vec3 color;
	if(f > 1.0)
		color = vec3(0.0, 0.0, 0.0); // background
	else
	{
		vec3 specular;
		float diffuse;
		float zc = sqrt(1.0 - f*f);
		vec3 norm = vec3(rad * f / r, zc);

		vec3 lightVector = LIGHTPOS - pos3;
		lightVector = normalize(lightVector);
		diffuse = max(0.0, dot(norm, lightVector)) + AMBIENT;

		vec3 cameraVector = vec3(0.0, 0.0, 1.0);

		vec3 halfVector = normalize(lightVector + cameraVector);
		float nxHalf = max(0.0,dot(norm, halfVector));
		float specularPower = pow(nxHalf, 40.0);
		specular = vec3(2.0) * specularPower;

		vec3 testpos = norm / RF + vec3(best.xy, 0.0);
		testpos = testpos * vec3(TSCALE, TSCALE, TSCALE);
		float tt = testpos.x + testpos.y + testpos.z;
		if(fract(tt+time*.3) < .5)
			color = COLOR2;
		else
			color = COLOR;
		color = diffuse * color + specular;
	}

	gl_FragColor =  vec4(color, 1.0);
}