// Blank Slate - @P_Malin

// added pan/zoom - hard work stolen from other shaders, thanks @emackey
 
#ifdef GL_ES
precision highp float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;
uniform sampler2D backbuffer;

// somehow these enable pan/zoom controls (using magic)
uniform vec2 surfaceSize;
varying vec2 surfacePosition;

float kPI = acos(0.0);
float kHalfPi = asin(1.0);
float kTwoPI = kPI * 2.0;

// Removed so that it works again
//float cos(float v) // workaround for AMD Radeon on OS X
//{ 
//	return sin(v+kHalfPi);
//}

//#define ENABLE_MONTE_CARLO
//#define ENABLE_REFLECTIONS
#define ENABLE_FOG
#define ENABLE_SPECULAR
#define ENABLE_POINT_LIGHT
#define ENABLE_POINT_LIGHT_FLARE

#ifdef ENABLE_MONTE_CARLO
vec4 gPixelRandom;
vec3 gRandomNormal;

void CalcPixelRandom()
{
	// Nothing special here, just numbers generated by bashing keyboard
	vec4 s1 = sin(time * 3.22 + gl_FragCoord.xxxx * vec4(324.324234, 563.324234, 657.324234, 764.324234)) * 543.3423;
	vec4 s2 = sin(time * 1.3422 + gl_FragCoord.yyyy * vec4(567.324234, 435.324234, 432.324234, 657.324234)) * 654.5423;
	gPixelRandom = fract(2142.4 + s1 + s2);
	gRandomNormal = normalize( gPixelRandom.xyz - 0.5);
}
#endif

struct C_Ray
{
	vec3 vOrigin;
	vec3 vDir;
};
 
struct C_HitInfo
{
	vec3 vPos;
	float fDistance;
	vec3 vObjectId;
};
 
struct C_Material
{
	vec3 cAlbedo;
	float fR0;
	float fSmoothness;
	vec2 vParam;
};
	
	
float hash(float v)
{
	return fract(fract(v*1234.5678)*(v+v)*12345.678);
}

vec2 hash(vec2 v) 
{
	vec2 n;
	n.x=fract(cos(v.y-v.x*841.0508)*(v.y+v.x)*3456.7821);
	n.y=fract(sin(v.x+v.y*804.2048)*(v.x-v.y)*5349.2627);
	return n;
}

float sphere(vec3 position, float radius)
{
	return length(position)-radius; 
}

float cube(vec3 p, vec3 s)
{
	vec3 d = (abs(p) - s);
	return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

float torus( vec3 p, vec2 t )
{
	vec2 q = vec2(length(p.xz)-t.x, p.y);
	return length(q)-t.y;
}

float cylinder(vec3 p, float l, float r)
{
	return max(abs(p.y-l)-l, length(p.xz)-r);
}

float cone(vec3 p, float l, vec2 r)
{
	float m = 1.-(p.y*.5)/l;
	return max(length(p.xz)-mix(r.y, r.x, m), abs(p.y-l)-l);
}

float icosahedral(vec3 p, float e, float r)
{
	vec2 n = vec2(.577, -.577);
	float a = .357;
	float b = .934;
	float s = pow(abs(dot(p,n.yyy)),e);
	s += pow(abs(dot(p,n.yxx)),e);
	s += pow(abs(dot(p,n.xyx)),e);
	s += pow(abs(dot(p,n.xxy)),e);
	s += pow(abs(dot(p,vec3( 0.,a,b))),e);
	s += pow(abs(dot(p,vec3(0.,-a,b))),e);
	s += pow(abs(dot(p,vec3( b,0.,a))),e);
	s += pow(abs(dot(p,vec3(-b,0.,a))),e);
	s += pow(abs(dot(p,vec3( a,b,0.))),e);
	s += pow(abs(dot(p,vec3(-a,b,0.))),e);
	s = pow(s, 1./e);
	return s-r;
}

//via http://glsl.herokuapp.com/e#4841.11
float partition_noise(vec2 p) 
{
	vec2 id;
	
	id = floor(floor(p)-.5);
	
	p *= floor(hash(id) * 2.)+1.;
	id = floor(p);
	
	p.yx *= floor(hash(id) * 3.)-4.;
	id -= floor(p);

	p *= floor(hash(id) * 2.)+1.;
	id = floor(p);

	p -= id;

	vec2 u = abs(p - .5) * 2.;

	return max(u.x, u.y);
}

float cross(float x)
{
	return abs(fract(x-.5)-.5)*2.;  
}

mat2 rmat(in float r)
{
	float c = cos(r);
	float s = sin(r);
	return mat2(c, s, -s, c);
}

vec3 RotateX( const in vec3 vPos, const in float fAngle )
{
	float s = sin(fAngle);
	float c = cos(fAngle);
	
	vec3 vResult = vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);
	
	return vResult;
}
 
vec3 RotateY( const in vec3 vPos, const in float fAngle )
{
	float s = sin(fAngle);
	float c = cos(fAngle);
	
	vec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);
	
	return vResult;
}
     
vec3 RotateZ( const in vec3 vPos, const in float fAngle )
{
	float s = sin(fAngle);
	float c = cos(fAngle);
	
	vec3 vResult = vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);
	
	return vResult;
}
 
vec4 DistCombineUnion( const in vec4 v1, const in vec4 v2 )
{
	//if(v1.x < v2.x) return v1; else return v2;
	return mix(v1, v2, step(v2.x, v1.x));
}
 
vec4 DistCombineIntersect( const in vec4 v1, const in vec4 v2 )
{
	return mix(v2, v1, step(v2.x,v1.x));
}
 
vec4 DistCombineSubtract( const in vec4 v1, const in vec4 v2 )
{
	return DistCombineIntersect(v1, vec4(-v2.x, v2.yzw));
}
 
vec3 DomainRepeatXZGetTile( const in vec3 vPos, const in vec2 vRepeat, out vec2 vTile )
{
	vec3 vResult = vPos;
	vec2 vTilePos = (vPos.xz / vRepeat) + 0.5;
	vTile = floor(vTilePos + 1000.0);
	vResult.xz = (fract(vTilePos) - 0.5) * vRepeat;
	return vResult;
}
 
vec3 DomainRepeatXZ( const in vec3 vPos, const in vec2 vRepeat )
{
	vec3 vResult = vPos;
	vec2 vTilePos = (vPos.xz / vRepeat) + 0.5;
	vResult.xz = (fract(vTilePos) - 0.5) * vRepeat;
	return vResult;
}
 
vec3 DomainRepeatY( const in vec3 vPos, const in float fSize )
{
	vec3 vResult = vPos;
	vResult.y = (fract(vPos.y / fSize + 0.5) - 0.5) * fSize;
	return vResult;
}
 
vec3 DomainRotateSymmetry( const in vec3 vPos, const in float fSteps )
{
	float angle = atan( vPos.x, vPos.z );

	float fScale = fSteps / (kTwoPI);
	float steppedAngle = (floor(angle * fScale + 0.5)) / fScale;

	float s = sin(-steppedAngle);
	float c = cos(-steppedAngle);

	vec3 vResult = vec3( c * vPos.x + s * vPos.z,
			     vPos.y,
			    -s * vPos.x + c * vPos.z);

	return vResult;
}
 
float GetDistanceXYTorus( const in vec3 p, const in float r1, const in float r2 )
{
	vec2 q = vec2(length(p.xy)-r1,p.z);
	return length(q)-r2;
}
float GetDistanceYZTorus( const in vec3 p, const in float r1, const in float r2 )
{
	vec2 q = vec2(length(p.yz)-r1,p.x);
	return length(q)-r2;
}
float GetDistanceCylinderY(const in vec3 vPos, const in float r)
{
	return length(vPos.xz) - r;
}
float GetDistanceBox( const in vec3 vPos, const in vec3 vSize )
{
	vec3 vDist = (abs(vPos) - vSize);
	return max(vDist.x, max(vDist.y, vDist.z));
}
 
float GetDistanceRoundedBox( const in vec3 vPos, const in vec3 vSize, float fRadius )
{
	vec3 vClosest = max(min(vPos, vSize), -vSize);
	return length(vClosest - vPos) - fRadius;
}
 
// result is x=scene distance y=material or object id; zw are material specific parameters (maybe uv co-ordinates)
vec4 GetDistanceScene( const in vec3 vPos )
{          
	vec4 vResult 			= vec4(10000.0, -1.0, 0.0, 0.0);
        vec3 position 			= vPos;
	position.z                  	+= 1.5;
	position.y 			+= .5;
	float ship                  	= vResult.x;
	

	//main hulls
	vec3 hull_position          	= position;
	hull_position.x             	= max(abs(position.x),.04);
	
	//laterial insets 
	hull_position.x             	*= hull_position.z > .1     
	&& hull_position.z < 1.1 
	? 1.05 : 1.;

	hull_position.x             	*= hull_position.z > 1.85   
	&& hull_position.z < 2. 
	? 1.025 : 1.;
	
	hull_position.y             	= abs(hull_position.y)*.75+position.z*.001;
	
	
	vec3 hull_scale             	= vec3(1.);
	hull_scale.x                	= position.z*.3+.45, 
	hull_scale.y                	= position.z*.05+.085;
	hull_scale.y               	+= -abs(max(abs(position.x*.87),position.z*.025)*.187);
	hull_scale.z               	= min(hull_position.y+4., 4.);
	hull_scale.z               	+= abs(position.y);
	
	
	//inner hull
	vec3 hull_inner_scale           = hull_scale;
	hull_inner_scale.x          	+= abs(position.x)*.03-.01-position.z * .0005;
	hull_inner_scale.y          	= position.z < 4.1 ? .05 : hull_inner_scale.y;
	hull_inner_scale.z          	+= abs(position.x)*.012 + .15;
	
	vec3 hull_inner_position        = hull_position;    
	hull_inner_position.y           = abs(position.y)<abs(hull_position.y) ? position.y : hull_position.y; //delete?

	float hull_inner        	= cube(hull_inner_position, hull_inner_scale);
	
	
	vec3 hull_outer_scale           = hull_scale * vec3(1.05,1.05, 1.031);
	hull_outer_scale.y         	+= position.y > .5 ? -position.z * .025 : 0.;
	
	hull_position.y             	= abs(hull_position.y-.05+position.z*.0025);
	
	float hull_outer            	= cube(hull_position, hull_outer_scale);

	hull_outer                  	= max(hull_outer, -hull_inner);
	ship                        	= min(hull_outer, ship);    

	bool inner_hull             	= hull_inner < hull_outer;
	bool outer_hull             	= hull_inner > hull_outer;
	
	bool engines            	= false;
	bool bridge_tower	        = false;
	bool aft 			= false;
	bool domes 			= false;
	
	//hull details
	float forward_partitions        = partition_noise(floor(position.z*8.)/8.+position.yx*8.);
	float deck_partitions		= partition_noise(floor(position.x*8.)/8.+position.yz*8.);
	
	float hull_plating          	= partition_noise
					(
					floor(position.xz*31.)/31.
					+floor(position.xz*63.)/63.
					+position.xz*2.5-.41
					+abs(position.z)*.2
					);
	
	float hull_panels       	= max(hull_plating, .85) * 4.; 
	float forward_panels       	= max(forward_partitions, .85);
	
	float z_floor_noise        	= hash
					(
					floor(position.z*13.+position.z)/8.
					+floor(position.z*5.)/3.
					);
	
	z_floor_noise         		= floor(z_floor_noise*8.)/8.;
	
	float outboard_partitions	= partition_noise
					(
					floor(position.x*16.)/8. +
					z_floor_noise +
					position.yz * 8.*
					vec2(3.5, 1.2*(1.+hull_plating*.05))
					);

	
	//aft hull && engines
	if(inner_hull && hull_position.z > 4.0 && hull_position.y < .375)
	{   
		//aft structures
		aft                 		= true;
		
		hull_inner			= max(hull_inner-.05, -hull_outer);
		vec2 absxy			= abs(position.xy*1.1);
		bool columns			= mod(absxy.x-.25, .85) > .3625;
		bool spars			= mod(absxy.x+absxy.y, .25) > .025 ^^ mod(absxy.x-absxy.y, .25) > .025;

		hull_inner_scale.z		+= columns || spars ? .00 : -.0125;     

		hull_inner			= cube(hull_inner_position, hull_inner_scale);
		hull_inner			+= columns && !spars ? -.05 : -0.;
		hull_inner			+= !columns && !spars ? fract((absxy.x-absxy.y)*16.+.9)*0.01 : 0.;
		hull_inner			+= spars ? 0.01 : 0.05;
		hull_inner			+= !spars && columns ? forward_panels*.005 : 0.;
		hull_outer			= max(hull_outer,-hull_inner);

		//main engines
		vec3 engine_position    	= position.yzx;
		engine_position.z       	= abs(engine_position.z) < .4 ? engine_position.z : abs(engine_position.z)-.8;
	
		engine_position         	+= -vec3(0.,4.1,0.);
		float engine_angle      	= atan(engine_position.x, engine_position.z)/6.28;
			
		float engine_contour    	= clamp(engine_position.y*.5,.05,.15);
		engine_contour          	= engine_position.y > .35 ? .2 : engine_contour;
			
		vec2 radii          		= vec2(engine_contour, .25);
		float depth         		= .21;
		float engine           	 	= cone(engine_position, depth, radii);
	
		engine              		+= fract(engine_position.y*8.)>.2 ? .01 : 0.;
		engine              		+= fract(engine_angle*16.)>.1 ? .01 : 0.;
		engine_position.y      	 	+= -.125;
		float engine_mask      	 	= cone(engine_position, depth, radii);
		engine_mask            	 	+= fract(engine_position.y*8.)>.2 ? .01 : 0.;
		engine              		= max(engine, -engine_mask);    
		
		//booster engines
		vec3 booster_position   	= position.yzx;
		booster_position.x      	= abs(booster_position.x)-.165;
		booster_position.z      	= abs(booster_position.z)-.4;
		booster_position        	+= vec3(0.,-4.15,0.);
		float booster_radius    	= length(booster_position.xz);
		float booster_angle     	= atan(booster_position.x, booster_position.z)/6.28;
		float booster_contour   	= booster_position.y > .1 ? .115 : .15;
		float booster_length    	= booster_radius < .065 ? .12  : .195 - booster_radius * booster_position.y;
		float booster           	= cylinder(booster_position, booster_length , booster_contour);
		
		booster             		+= fract(booster_position.y*8.)>.8 ? .01 : 0.;
		booster            		+= fract(booster_angle*16.)>.1 ? .01 : 0.;

		float engines         		= min(engine, booster);
		ship               		= min(engines, ship);
	}
	
	//conning tower
	float tower = vResult.x;
	if(position.y > 0.)
	{                   
		//bridge
		vec3 bridge_position            = hull_position;
		bridge_position.y       	+= -hull_position.z * .05 - .46;
		bridge_position.z          	+= -3.8;
		
		vec3 bridge_scale          	= vec3(1.);
		bridge_scale.x             	= -bridge_position.z*.05+.8;
		bridge_scale.x             	+= abs(bridge_position.y) < .035 ? outboard_partitions*-.025 : 0.;
		bridge_scale.y			= -abs(bridge_position.x)*.1+.125;
		bridge_scale.z			= -bridge_position.z*.01-abs(bridge_position.x)*.15+.25;
		
		float bridge			= cube(bridge_position, bridge_scale);
		
		vec2 bridge_detail		= hash(floor(hull_position.xy*8.)+floor(hull_position.xy*18.))+.25;
		
		vec3 bridge_decks_position      = bridge_position;
		bridge_decks_position.z         = mod(bridge_position.z, .0625)-.00375;
		bridge_decks_position.z         = max(abs(bridge_decks_position.z)*2., abs(bridge_position.z)-bridge_detail.x*.1)+.05;
		float bridge_decks          	= cube(bridge_decks_position, bridge_scale);
		bridge_decks                	+= -forward_panels*.001;
		
		//sensor bar
		vec3 sensor_bar_position        = bridge_position;
		sensor_bar_position.y           += -.22;
		sensor_bar_position.z           += -.07;
		
		vec3 sensor_bar_scale           = vec3(1.);
		sensor_bar_scale.x          	= .4;
		sensor_bar_scale.y          	= sensor_bar_position.z*.01+.015;
		sensor_bar_scale.z          	= -abs(position.x)*.025+.075;
	
		float sensor_bar            	= cube(sensor_bar_position, sensor_bar_scale);
		sensor_bar                  	+= fract(sensor_bar_position.x*8.-.1)>.8 ? -.0025 : 0.;
		sensor_bar                  	+= fract(sensor_bar_position.z*8.-.3)>.4 ? .0035 : 0.;
		
		
		vec3 sensor_bar_base_position   = sensor_bar_position;
		sensor_bar_base_position.y      += .08;
		sensor_bar_base_position.z      += -.02;
		
		vec3 sensor_bar_base_scale      = vec3(1.);
		sensor_bar_base_scale.x         = -sensor_bar_position.y*.5-sensor_bar_position.z*.6-abs(sensor_bar_position.x)*.25+.05;
		sensor_bar_base_scale.y         = .074;
		sensor_bar_base_scale.z         = .08+sensor_bar_position.y*-.5;
		sensor_bar_base_scale.z         += abs(sensor_bar_base_position.x)<.1
						&& abs(sensor_bar_base_position.y-.025)<.015            
						&& sensor_bar_base_position.z<-.1
		? -.005 : 0.;       
		
		float sensor_bar_base           = cube(sensor_bar_base_position, sensor_bar_base_scale);        
		
		sensor_bar                  	= min(sensor_bar, sensor_bar_base);
		
		//ray domes
		vec3 ray_dome_position          = bridge_position;  
		ray_dome_position.z         	+= .06;
		ray_dome_position.y         	+= -.16;
		ray_dome_position.y         	*= 1.3;
		ray_dome_position.x         	= abs(ray_dome_position.x)-.625;
			
		float ray_domes             	= icosahedral(ray_dome_position*1.1, 24., .11);
			
		vec3 support_position       	= ray_dome_position;
		support_position.y          	+= .07;
		float support               	= cube(support_position, vec3(.06));        
		float support_mask          	= cube(support_position, vec3(.065,.1,.065));       
			
		vec3 absp                   	= abs(support_position);
		bool struts                 	= absp.x<.06 ^^ absp.z>.06; 
		bool spars                  	=  fract(abs(absp.x-absp.y))>.02
						&& fract(abs(absp.z-absp.y))>.02;
		
		support                     	+= spars && !struts ? .01 : -.015;
	
		support                     	= max(support, -support_mask);
			
		//tower 	
		vec3 tower_position         	= hull_position;
		tower_position.z            	+= -4.045;
		tower_position.z            	+= tower_position.z > 4. ? tower_position.y * .3 : 0.;
		tower_position.y        	+= -.51;
		
		vec3 tower_scale            	= vec3(1.);
		tower_scale.x               	= -tower_position.y*.1+.15;
		tower_scale.y               	= .2;
		tower_scale.z               	= tower_position.z*.05;
		tower_scale.z               	+= tower_position.z > .2 ? -tower_position.y*.6+.4 : tower_position.y*.25+.3;
		tower_scale.x               	+= fract(tower_position.y*16.-z_floor_noise-.3) > .6 - z_floor_noise * .05 
						&& tower_position.z + tower_position.y * .5 - z_floor_noise * .15 < .15
						&& tower_position.y < .14
						? outboard_partitions * -.015 : 0.;
		
		float tower                 	= cube(tower_position, tower_scale);
			
			
		vec3 tower_base_position    	= tower_position;
		tower_base_position.y       	+= .15;
		tower_base_position.z       	+= .05;
			
		vec3 tower_base_scale       	= tower_scale;
		tower_base_scale.x          	= -tower_position.y*.13+.19;
		tower_base_scale.z          	+= -.1;
		tower_base_scale.y          	= tower_position.z*.05+.1;
			
		float tower_base            	= cube(tower_base_position, tower_base_scale);
		
		float tower_vents       	= position.z > 3.8 ? fract(position.y*32.)*.05 : 0.;
		
		tower                       	+= abs(position.x) < .25-position.y*.1-.07 
		&& position.y < .93
		? tower_vents : 0.;
			
		//compositing
		tower                   	= min(tower, tower_base);       
		bridge_decks               	= min(bridge-.01, bridge_decks+.01);    
		bridge_decks               	= min(bridge_decks, support);
		ray_domes                  	= min(ray_domes, sensor_bar);
		domes                      	= ray_domes < bridge;
		tower                      	= min(tower, bridge_decks);
		bridge                     	= min(bridge, ray_domes); 
		tower                      	= min(bridge,tower);
		bridge_tower               	= tower < ship;
		
		ship                		= min(tower, ship);
	}
	hull_inner              	= max(hull_inner, -tower);
	hull_inner             		= max(hull_inner, -tower);
	ship                		= min(ship, hull_inner);


	//solar collector (round thing on the bottom)
	vec3 collector_position     	= position;
	collector_position.z        	+= -2.8;
	collector_position.xz       	*= rmat(3.14/4.);
	collector_position.y        	+= abs(collector_position.x)-.0125 < 0. 
					|| abs(collector_position.z)-.0125 < 0.
					? -.05 : 0.;

	collector_position.y 		*= 2.;
	collector_position.y    	+= -hull_plating * .005 + .45;
	
	float collector_scale       	= position.y < -hull_scale.y ? .45 : 0.;
	
	float collector             	= sphere(collector_position, collector_scale);
	bool solar_collector        	= collector < ship;
	
	
	//super structure for upper decks
	vec3 deck_position      	= hull_position;
	vec2 absxz              	= abs(position.xz*3.);
	if(position.y > 0. && !inner_hull)
	{
		bool indents    	= fract(absxz.y*.35 + .2)>.1;
		
		//outboard offset
		deck_position.x 	+= deck_position.z - deck_position.x * .06 > 1. + deck_position.x * .15    
					&& deck_position.z < 3.91 - deck_position.x * .985
					&& deck_position.x - deck_position.z * .135 < .2
					? -.3 : 0.;
	
		//lower decks	
		deck_position.y 	+= deck_position.z - deck_position.x > 1.75 
					&& deck_position.z > 1.285
					&& deck_position.z + deck_position.x *.3 < 4.45   
					&& deck_position.x < .4 + deck_position.z * .15
					? -.025 : 0.;
			
		//gun decks	
		deck_position.y 	+= deck_position.z - deck_position.x > 1.65 
					&& deck_position.z > 2.5
					&& deck_position.z + deck_position.x *.5 < 4.38
					&& deck_position.x < deck_position.z * .25 +.4
					? -.015 : 0.;

		//turrets
		vec3 turret_position    = hull_position - vec3(position.z * .2-.15,.045+hull_position.z*.01, 3.23);
		
		turret_position.z   	= abs(abs(abs(turret_position.z)-.125)-.125)-.125;
		turret_position.x   	= abs(turret_position.x)-.5;
			
	
		vec2 turret_radius  	= vec2(.02, .02);
		turret_radius.x     	= turret_position.y > .01 ? .04 : .01;
		turret_radius.y     	= abs(turret_position.z) > .015 
					|| turret_position.x > .0025 
					? .001 : turret_radius.y+.005;
		
		float turret_depth  	= .025;
		
		float turret        	= cone(turret_position, turret_depth, turret_radius);
		vec3 barrel_position    = turret_position;
		barrel_position.y   	+= -.045;

		
		float barrel       	= cube(barrel_position, vec3(.03,0.005,.005));
		turret          	= min(turret, barrel);

		deck_position.y     	+= turret < .05 ? .01 : 0.;   
		ship            	= position.y > 0. ? min(ship, turret) : ship;
		
		
		//mid decks
		deck_position.y 	+= deck_position.z - deck_position.x        > 2.25 
					&& deck_position.z + deck_position.x *.4    < 4. 
					&& deck_position.x + deck_position.z * .1   > .26    
					&& deck_position.x < .5 
					? -.05 : 0.;
		
		
		//upper decks
		deck_position.y 	+= deck_position.z - deck_position.x * .125 > 2.9
					&& deck_position.z + deck_position.x *.4    < 3.9 
					&& deck_position.x              	    < .3 
					? -.02 : 0.;
		
		//midship deck
		deck_position.y 	+= deck_position.z - deck_position.x * .3   > .75
					&& deck_position.z + deck_position.x        < 2.19
					&& deck_position.x < .6 
					&& deck_position.x > -.25
					? -.01 : 0.;
		
		//midship hatches
		deck_position.y 	+= deck_position.z - deck_position.x * .3   > .85
					&& deck_position.z + deck_position.x        < 1.9
					&& deck_position.x < .55 
					&& deck_position.x > .25
					? -.01 : 0.;
	
	
		//bulwarks
		deck_position.y 	+= deck_position.z - deck_position.x        > .092
					&& deck_position.x - deck_position.z *.283  < .5
					&& deck_position.z  < 4.
					&& deck_position.x-deck_position.z*.25  > -.25
					&& indents
					? -.005 * hull_position.x : 0.;
		
		
		//sensor deck
		deck_position.y 	+= deck_position.z - deck_position.x * .5   > -.48  
					&& deck_position.z + deck_position.x        < .34   
					&& deck_position.x              < .28
					? -.014  : 0.;
		
		
		//forecastle
		deck_position.y 	+= deck_position.z - deck_position.x * 5.5   > -1.45  
					&& deck_position.z + deck_position.x * 2.    < -.54   
					? -.01  : 0.;
	
		//upper deck superstructure
		vec3 deck_upper_position= hull_position;
		deck_upper_position.y   = hull_position.y- .15 - deck_position.y*.05;
		deck_upper_position.z   += -3.16;
		
		vec3 deck_upper_scale   = vec3(1.);
		deck_upper_scale.x      = hull_scale.x-deck_position.x-.8;
		deck_upper_scale.x      += deck_position.z < 2.7 ? deck_upper_position.z : 0.;
		deck_upper_scale.x      += deck_position.z > 3.9 ? -deck_upper_position.z*2.7+2. : 0.;
		deck_upper_scale.x      += deck_partitions*.025;
		deck_upper_scale.y      = hull_scale.y;
		deck_upper_scale.z      = .55 - forward_partitions*.015;
		deck_upper_scale.z      += deck_position.z > 3. ? .4 : 0.;
		
		bool upper_deck_bounds  = deck_position.z - deck_position.x * .3   > .5
					&& deck_position.z + deck_position.x            < 1.9
					&& deck_position.x < .55 
					&& deck_position.x > .15;
		
		deck_upper_scale.x  	*= !upper_deck_bounds ? 1. : 2.4;
		
		float deck_upper    	= cube(deck_upper_position, deck_upper_scale);
		
		
		//mid deck superstructure
		vec3 deck_mid_position  = hull_position;
		deck_mid_position.y     = hull_position.y - .1;
		deck_mid_position.z     -= 3.16;
		
	
		
		vec3 deck_mid_scale     = vec3(1.);
		deck_mid_scale.x        = hull_scale.x-deck_position.x;
		deck_mid_scale.x        += deck_position.z < 2.7 ? deck_mid_position.z : 0.;
		deck_mid_scale.x        += deck_position.z > 3.9 ? -deck_mid_position.z*2.7+2. : 0.;
		deck_mid_scale.x        += deck_partitions*.025;        
		deck_mid_scale.y        = hull_scale.y;        
		deck_mid_scale.z        = .93 - forward_partitions*.015;
		
		bool mid_deck_bounds    = deck_position.z - deck_position.x * .3   > .5
					&& deck_position.z + deck_position.x            < 1.9
					&& deck_position.x < .55 
					&& deck_position.x > .15;
		
		deck_mid_scale.x	*= !mid_deck_bounds ? 1. : 2.4;
	
		float deck_mid          = cube(deck_mid_position, deck_mid_scale);
	
		ship                    = min(ship, deck_upper);
		ship                    = min(ship, deck_mid);
	}
	else
	{
	
		//solar collector berth
		deck_position.y 	*= deck_position.z - deck_position.x    > 1.9
					&& deck_position.z + deck_position.x    < 3.65
					&& deck_position.x                      < deck_position.z * .23 
					? .9 : 1.;
		
		deck_position.y 	+= length(collector_position)-.55 < 0. ? .05 : 0.;
			
		vec2 absxz      	= abs(position.xz*8.);
		bool indents    	= fract(absxz.y*.35+.5)>.1;
		bool columns    	= mod(absxz.y-.25-position.y, 1.) > .5 && abs(position.x) > .10;
		bool spars      	= mod(absxz.x+absxz.y, 1.25) > .025 ^^ mod(absxz.x-absxz.y, 1.25) > .025;
		
		
		//fighter bays
		deck_position.y 	+= deck_position.z - deck_position.x        > .92
					&& deck_position.x - deck_position.z *.25   < .3
					&& deck_position.x -deck_position.z*.25     > .15
					&& deck_position.z                          < 4.
					&& indents && !spars
					? .01 * hull_position.x : 0.;
		
		
		//forward bay
		deck_position.y 	+= deck_position.z - deck_position.x * .5   > -.7   
					&& deck_position.x          < .2     
					&& deck_position.z          < -.3    
					? -.0125 - hull_plating * .0025 : 0.;      
		
		//main docking bay border
		deck_position.y 	+= deck_position.z  > .25
					&& deck_position.z  < 1.25
					&& deck_position.x  < .45
					? -.01 : 0.;
		
		//main docking bay
		bool bay_area 		= deck_position.z   > .2
					&& deck_position.z  < 1.2
					&& deck_position.x  < .4;
		
		
		deck_position.y 	+= bay_area ? -hull_position.x*0.25+.1 : 0.;

		deck_position.y 	+= bay_area
					&& columns
					? -.01 : .0;
		
		deck_position.y 	+= bay_area
					&& spars
					&& !columns
					? -0.004 : 0.;
			
					//main docking bay border
		deck_position.y 	+= deck_position.z  > .75
					&& deck_position.z  < 1.95
					&& deck_position.x  < .45
					&& !spars
					? -abs(position.x)*.001 : 0.;   
	}
	deck_position   		+= -.005;
	ship                    	= min(ship, hull_inner);
	
	bool upper_decks        	= hull_position.y != deck_position.y 
					|| hull_position.x != deck_position.x 
					|| hull_position.z != deck_position.z; 
	
		
	vec3 deck_scale         	= hull_scale;
	
	deck_scale              	*= position.y > 0. && position.z < 4. && upper_decks ? 1.01 : 1.;
	float decks             	= cube(deck_position, deck_scale);
		
	ship                    	= position.y < -.075 && position.z < 4. ? max(hull_inner,decks) : ship;
	ship                    	= min(decks, ship);
	ship                    	= min(collector, ship);
	
	
	//border around the edge of the main hull
	vec3 border_mask_position   	= abs(hull_scale);
	border_mask_position.x      	*= -abs(hull_position.x*1.5)+hull_position.z*.5+1.25;
	border_mask_position.y      	*= 1.1;
	border_mask_position.z      	+= position.z-hull_position.x*.1 < 4.5 ? .05 : 0.;
		
	float hull_border_mask      	= cube(hull_position, border_mask_position);
	
	float hull_border           	= abs(fract((hull_position.x*2.+hull_position.z*8.)*4.)-.5)*2.;
	hull_border                 	= min(hull_border, .1)*.005-.0035;
		
	bool border                 	= hull_border_mask > hull_outer && !inner_hull && !upper_decks;
	
	
	
	hull_border                 	+= outboard_partitions * .00015;
	outboard_partitions         	+= max(outboard_partitions, .85)*4.;    
		
	vec2 xz_floor_noise                	= hash(floor(hull_position.xz*8.+deck_scale.y*4.+abs(8.-hull_position.zx*1.5)*vec2(32., 23.)));
	xz_floor_noise                 	= max(floor(xz_floor_noise*32.)-25., .0)*.025*(.25-position.x)*xz_floor_noise;


	//outboard hangar bays
	vec3 bay_positions         	= position;
	bay_positions.z            	+= -3.15;
	bay_positions.z            	= mod(bay_positions.z+mod(bay_positions.z, 3. + bay_positions.z * .5), 3.4)-.5525;
	bay_positions.y           	+= z_floor_noise * .025 + xz_floor_noise.y * .005 - .01;
	
	vec3 bay_scale             	= vec3(1.);
	bay_scale.x             	= 4.;
	bay_scale.y             	= .0175 - (xz_floor_noise.x - xz_floor_noise.y) * hull_scale.x * .035 + z_floor_noise*position.x*.0025;
	bay_scale.y             	+= position.z < 0.1 ? xz_floor_noise.x * .4 -.01 : 0.;
	bay_scale.y             	+= abs(position.x) < .05 ? -.04 : 0.;
	bay_scale.z             	= position.z*.095+.1+abs(position.x)*.1;
	
	float hangar_bays           	= cube(bay_positions, bay_scale);

	
	
	//composite details
	bool wake_line          	= abs(position.y)<.055;
	
	hull_panels             	*= border || bridge_tower ? .5 : 1.;
	hull_panels             	*= upper_decks ? .75 : 1.;
	

	float hull_inner_detail     	= wake_line
					&& hangar_bays > 0.
					&& outboard_partitions<3.95
					? .01 : outboard_partitions *.001;

	float hull_detail_floor		= floor(8.*cross(position.z+cross(position.z*5.)+cross(position.y*3.))/3.);
	hull_inner_detail       	+= wake_line && hangar_bays > 0.
					&& outboard_partitions<3.95
					&& position.z > -1.4
					? -min(hull_detail_floor,.75)*.02 : 0.;
	
	//detailing
	ship               		+= wake_line ? (z_floor_noise < .1 ? -.0075 : 0.) : 0.;                  
	ship               		= max(ship, -hangar_bays);
	ship               		= border ? ship + hull_border : ship+ hull_border ;
	ship               		= bridge_tower || upper_decks ? ship + outboard_partitions *.0001 : ship;
	ship               		= (bridge_tower || outer_hull) && !border ? ship + hull_panels * .0025 : ship;  
	ship               		= !aft && !bridge_tower && inner_hull ? ship + hull_inner_detail: ship; 
	
	vResult.y			= 2.;
	vResult.x 			= ship;  
	return vResult;
}

C_Material GetObjectMaterial( const in vec3 vObjId, const in vec3 vPos )
{
	C_Material mat;
		       
	if(vObjId.x < 1.5)
	{
		// floor
		mat.fR0 = 0.02;
		mat.fSmoothness = 0.0;
		mat.cAlbedo = vec3(0.7, 0.8, 0.3);
	}
	else
	if(vObjId.x < 2.5)
	{
		// sphere
		mat.fR0 = 0.05;
		mat.fSmoothness = 0.9;
		mat.cAlbedo = vec3(0.05, 0.35, 0.75);
	}
	
	return mat;
}
vec3 GetSkyGradient( const in vec3 vDir )
{
	float fBlend = vDir.y * 0.5 + 0.5;
	return mix(vec3(0.0, 0.0, 0.0), vec3(0.4, 0.9, 1.0), fBlend);
}
vec3 GetLightPos()
{
	vec3 vLightPos = vec3(-2.0, 1.0, 3.0);
	#ifdef ENABLE_MONTE_CARLO        
	vLightPos += gRandomNormal * 0.2;
	#endif
	return vLightPos;
}
vec3 GetLightCol()
{
	return vec3(32.0, 6.0, 1.0) * 10.0;
}
 
vec3 GetAmbientLight(const in vec3 vNormal)
{
	return GetSkyGradient(vNormal);
}

#define kFogDensity 0.1025
void ApplyAtmosphere(inout vec3 col, const in C_Ray ray, const in C_HitInfo intersection)
{
	#ifdef ENABLE_FOG
	// fog
	float fFogAmount = exp(intersection.fDistance * -kFogDensity);
	vec3 cFog = GetSkyGradient(ray.vDir);
	col = mix(cFog, col, fFogAmount);
	#endif
       
	// glare from light (a bit hacky - use length of closest approach from ray to light)
	#ifdef ENABLE_POINT_LIGHT_FLARE
	vec3 vToLight = GetLightPos() - ray.vOrigin;
	float fDot = dot(vToLight, ray.vDir);
	fDot = clamp(fDot, 0.0, intersection.fDistance);
       
	vec3 vClosestPoint = ray.vOrigin + ray.vDir * fDot;
	float fDist = length(vClosestPoint - GetLightPos());
	col += GetLightCol() * 0.01/ (fDist*fDist);
	#endif     
}
vec3 GetSceneNormal( const in vec3 vPos )
{
	// tetrahedron normal
	float fDelta = 0.00125;

	vec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);
	vec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);
	vec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);
	vec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);

	float f1 = GetDistanceScene( vPos + vOffset1 ).x;
	float f2 = GetDistanceScene( vPos + vOffset2 ).x;
	float f3 = GetDistanceScene( vPos + vOffset3 ).x;
	float f4 = GetDistanceScene( vPos + vOffset4 ).x;

	vec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;

	return normalize( vNormal );
}

#define kRaymarchEpsilon 0.0001
#define kRaymarchMatIter 128
#define kRaymarchStartDistance 0.001
// This is an excellent resource on ray marching -> http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm
void Raymarch( const in C_Ray ray, out C_HitInfo result, const float fMaxDist, const int maxIter )
{         
	result.fDistance = kRaymarchStartDistance;
	result.vObjectId.x = 0.0;
							   
	for(int i=0;i<=kRaymarchMatIter;i++)               
	{
		result.vPos = ray.vOrigin + ray.vDir * result.fDistance;
		vec4 vSceneDist = GetDistanceScene( result.vPos );
		result.vObjectId = vSceneDist.yzw;

		// abs allows backward stepping - should only be necessary for non uniform distance functions
		if((abs(vSceneDist.x) <= kRaymarchEpsilon) || (result.fDistance >= fMaxDist) || (i > maxIter))
		{
			break;
		}                         

		result.fDistance = result.fDistance + vSceneDist.x;     
	}
       
       
	if(result.fDistance >= fMaxDist)
	{
		result.vPos = ray.vOrigin + ray.vDir * result.fDistance;
		result.vObjectId.x = 0.0;
		result.fDistance = 1000.0;
	}
}

float GetShadow( const in vec3 vPos, const in vec3 vLightDir, const in float fLightDistance )
{
	C_Ray shadowRay;
	shadowRay.vDir = vLightDir;
	shadowRay.vOrigin = vPos;

	C_HitInfo shadowIntersect;
	Raymarch(shadowRay, shadowIntersect, fLightDistance, 32);
																									    
	return step(0.0, shadowIntersect.fDistance) * step(fLightDistance, shadowIntersect.fDistance );          
}

// http://en.wikipedia.org/wiki/Schlick's_approximation
float Schlick( const in vec3 vNormal, const in vec3 vView, const in float fR0, const in float fSmoothFactor)
{
	float fDot = dot(vNormal, -vView);
	fDot = min(max((1.0 - fDot), 0.0), 1.0);
	float fDot2 = fDot * fDot;
	float fDot5 = fDot2 * fDot2 * fDot;
	return fR0 + (1.0 - fR0) * fDot5 * fSmoothFactor;
}

float GetDiffuseIntensity(const in vec3 vLightDir, const in vec3 vNormal)
{
	return max(0.0, dot(vLightDir, vNormal));
}

float GetBlinnPhongIntensity(const in C_Ray ray, const in C_Material mat, const in vec3 vLightDir, const in vec3 vNormal)
{           
	vec3 vHalf = normalize(vLightDir - ray.vDir);
	float fNdotH = max(0.0, dot(vHalf, vNormal));

	float fSpecPower = exp2(4.0 + 6.0 * mat.fSmoothness);
	float fSpecIntensity = (fSpecPower + 2.0) * 0.125;

	return pow(fNdotH, fSpecPower) * fSpecIntensity;
}

// use distance field to evaluate ambient occlusion
float GetAmbientOcclusion(const in C_Ray ray, const in C_HitInfo intersection, const in vec3 vNormal)
{
	vec3 vPos = intersection.vPos;
       
	float fAmbientOcclusion = 1.0;
       
	float fDist = 0.0;
	for(int i=0; i<=5; i++)
	{
		fDist += 0.1;

		vec4 vSceneDist = GetDistanceScene(vPos + vNormal * fDist);

		fAmbientOcclusion *= 1.0 - max(0.0, (fDist - vSceneDist.x) * 0.2 / fDist );                                   
	}
       
	return fAmbientOcclusion;
}
 
vec3 GetObjectLighting(const in C_Ray ray, const in C_HitInfo intersection, const in C_Material material, const in vec3 vNormal, const in vec3 cReflection)
{
	vec3 cScene ;
	
	vec3 vSpecularReflection = vec3(0.0);
	vec3 vDiffuseReflection = vec3(0.0);
	
	float fAmbientOcclusion = GetAmbientOcclusion(ray, intersection, vNormal);
	vec3 vAmbientLight = GetAmbientLight(vNormal) * fAmbientOcclusion;
	
	vDiffuseReflection += vAmbientLight;
	
	vSpecularReflection += cReflection * fAmbientOcclusion;
		       
	#ifdef ENABLE_POINT_LIGHT
	vec3 vLightPos = GetLightPos();
	vec3 vToLight = vLightPos - intersection.vPos;
	vec3 vLightDir = normalize(vToLight);
	float fLightDistance = length(vToLight);
	
	float fAttenuation = 1.0 / (fLightDistance * fLightDistance);
	
	float fShadowBias = 0.1;             
	float fShadowFactor = GetShadow( intersection.vPos + vLightDir * fShadowBias, vLightDir, fLightDistance - fShadowBias );
	vec3 vIncidentLight = GetLightCol() * fShadowFactor * fAttenuation;
	
	vDiffuseReflection += GetDiffuseIntensity( vLightDir, vNormal ) * vIncidentLight;                                                                                 
	vSpecularReflection += GetBlinnPhongIntensity( ray, material, vLightDir, vNormal ) * vIncidentLight;
	#endif ENABLE_POINT_LIGHT
	
	vDiffuseReflection *= material.cAlbedo;              
	
	#ifdef ENABLE_SPECULAR
	float fFresnel = Schlick(vNormal, ray.vDir, material.fR0, material.fSmoothness * 0.9 + 0.1);
	cScene = mix(vDiffuseReflection , vSpecularReflection, fFresnel);
	#else
	cScene = vDiffuseReflection;
	#endif
	
	return cScene;
}

vec3 GetSceneColourSimple( const in C_Ray ray )
{
	C_HitInfo intersection;
	Raymarch(ray, intersection, 16.0, 32);
					    
	vec3 cScene;

	if(intersection.vObjectId.x < 0.5)
	{
		cScene = GetSkyGradient(ray.vDir);
	}
	else
	{
		C_Material material = GetObjectMaterial(intersection.vObjectId, intersection.vPos);
		vec3 vNormal = GetSceneNormal(intersection.vPos);

		// use sky gradient instead of reflection
		vec3 cReflection = GetSkyGradient(reflect(ray.vDir, vNormal));

		// apply lighting
		cScene = GetObjectLighting(ray, intersection, material, vNormal, cReflection );
	}

	ApplyAtmosphere(cScene, ray, intersection);

	return cScene;
}

vec3 GetSceneColour( const in C_Ray ray )
{                                                           
	C_HitInfo intersection;
	Raymarch(ray, intersection, 30.0, 256);
			    
	vec3 cScene;
       
	if(intersection.vObjectId.x < 0.5)
	{
		cScene = GetSkyGradient(ray.vDir);
	}
	else
	{
		C_Material material = GetObjectMaterial(intersection.vObjectId, intersection.vPos);
		vec3 vNormal = GetSceneNormal(intersection.vPos);

		#ifdef ENABLE_MONTE_CARLO
		vNormal = normalize(vNormal + gRandomNormal / (5.0 + material.fSmoothness * 200.0));
		#endif

		vec3 cReflection;
		#ifdef ENABLE_REFLECTIONS    
		{
			// get colour from reflected ray
			float fSepration = 0.05;
			C_Ray reflectRay;
			reflectRay.vDir = reflect(ray.vDir, vNormal);
			reflectRay.vOrigin = intersection.vPos + reflectRay.vDir * fSepration;
															      
			cReflection = GetSceneColourSimple(reflectRay);                                                                         
		}
		#else
		cReflection = GetSkyGradient(reflect(ray.vDir, vNormal));                               
		#endif
		// apply lighting
		cScene = GetObjectLighting(ray, intersection, material, vNormal, cReflection );
	}
       
	ApplyAtmosphere(cScene, ray, intersection);
       
	return cScene;
}

void GetCameraRay( const in vec3 vPos, const in vec3 vForwards, const in vec3 vWorldUp, out C_Ray ray)
{
	vec2 vPixelCoord = gl_FragCoord.xy;
	#ifdef ENABLE_MONTE_CARLO
	vPixelCoord += gPixelRandom.zw;
	#endif
	vec2 vUV = ( vPixelCoord / resolution.xy );
	vec2 vViewCoord = vUV * 2.0 - 1.0;

	vViewCoord *= 0.75;
       
	float fRatio = resolution.x / resolution.y;

	vViewCoord.y /= fRatio;                           

	ray.vOrigin = vPos;

	vec3 vRight = normalize(cross(vForwards, vWorldUp));
	vec3 vUp = cross(vRight, vForwards);
	    
	ray.vDir = normalize( vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards);        
}

void GetCameraRayLookat( const in vec3 vPos, const in vec3 vInterest, out C_Ray ray)
{
	vec3 vForwards = normalize(vInterest - vPos);
	vec3 vUp = vec3(0.0, 1.0, 0.0);

	GetCameraRay(vPos, vForwards, vUp, ray);
}

vec3 OrbitPoint( const in float fHeading, const in float fElevation )
{
	return vec3(sin(fHeading) * cos(fElevation), sin(fElevation), cos(fHeading) * cos(fElevation));
}

vec3 Gamma( const in vec3 cCol )
{
	return cCol * cCol;
}

vec3 InvGamma( const in vec3 cCol )
{
	return sqrt(cCol);
}


vec3 Tonemap( const in vec3 cCol )
{
	// simple Reinhard tonemapping operator     
	vec3 vResult = cCol / (1.0 + cCol);

	return Gamma(vResult);
}

vec3 InvTonemap( const in vec3 cCol )
{
	vec3 vResult = cCol;
	vResult = clamp(vResult, 0.01, 0.99);
	vResult = InvGamma(vResult);
	return - (vResult / (vResult - 1.0));
}

void main( void )
{
	#ifdef ENABLE_MONTE_CARLO             
	CalcPixelRandom();
	#endif
       
	C_Ray ray;
       
	const float fCamreaInitialHeading = 2.5;
	const float fCamreaInitialElevation = 0.4;
	const float fCamreaInitialDist = 6.0;
	const float fCameraHeight = 0.9;
	const float fOrbitSpeed = 1.0;
	
	// This magic stolen from other 3d pan/zoom examples
	float fZoom = surfaceSize.y * 0.5 + 0.4;
	
	vec2 vCenterPosition = (0.5 - ( gl_FragCoord.xy / resolution )) * surfaceSize + surfacePosition;
	float fHeading = vCenterPosition.x * fOrbitSpeed + fCamreaInitialHeading;
	float fElevation = (vCenterPosition.y * fOrbitSpeed + fCamreaInitialElevation);
	
	vec3 vCameraPos = OrbitPoint(fHeading, fElevation) * fCamreaInitialDist * fZoom;
	
	vCameraPos += vec3(0.0, -fCameraHeight, 0.0);
	#ifdef ENABLE_MONTE_CARLO             
	float fDepthOfField = 0.025;
	vCameraPos += gRandomNormal * fDepthOfField;
	#endif
       
	GetCameraRayLookat( vCameraPos, vec3(0.0, 0.0, 0.0), ray);
	//GetCameraRayLookat(vec3(0.0, 0.0, -5.0), vec3(0.0, 0.0, 0.0), ray);
       
	vec3 cScene = GetSceneColour( ray );   
       
	float fExposure = 2.5;
	cScene = cScene * fExposure;
       
	#ifdef ENABLE_MONTE_CARLO                              
	vec3 cPrev = texture2D(backbuffer, gl_FragCoord.xy / resolution).xyz;
	// add noise to pixel value (helps values converge)
	cPrev += (gPixelRandom.xyz - 0.5) * (1.0 / 255.0);
	cPrev = InvTonemap(cPrev);
	// converge speed
	float fBlend = 0.9;
	vec3 cFinal = mix(cPrev, cScene, fBlend);
	#else
	vec3 cFinal = cScene;
	#endif
	
	cFinal = Tonemap(cFinal);
       	
	float fAlpha = 1.0;
        
	gl_FragColor = vec4( cFinal, fAlpha );
}