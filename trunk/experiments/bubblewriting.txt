#ifdef GL_ES
precision mediump float;
#endif

// dashxdr 20140626
// This came from bubble writing used in ace_animpuzzle android app abortion
// https://play.google.com/store/apps/details?id=ace.animpuzzle
// QUESTION QUESTION QUESTION QUESTION
// Where does everyone hang out to talk about shaders + glshadersandbox?

const vec3 COLOR = vec3(1.0, 0.0, 0.0);
const vec3 COLOR2 = vec3(1.0, 1.0, 1.0);
const vec3 LIGHTPOS = vec3(-10.5, 10.0, 10.0);
const float AMBIENT = .3;
const float TSCALE = 5.0;
const float RF = 10.0;

varying vec2 surfacePosition;
uniform float time;

vec3 best;
vec2 pos;

void closest_point(vec2 origin, vec2 unitx, float low, float high, float k)
{
// find closest point on parabola

	vec2 unity = vec2(-unitx.y, unitx);
	vec2 oc = pos - origin;
	vec2 at;
	at.x = dot(oc, unitx);
	at.y = dot(oc, unity);

	float mid;
	for(int c=0;c<9;++c)
	{
		mid = (low + high) * .5;
		float kmid = k * mid;
		vec2 dir = vec2(1.0, 2.0 * kmid); // tangent at this point
		vec2 off = vec2(at.x - mid, at.y - mid * kmid); // offset to this pnt
		if(dot(dir, off)<0.0)
			high=mid;
		else
			low=mid;
	}
	float tx, ty;
	tx = mid;
	ty = k * tx * tx;
	vec2 center = origin + tx*unitx + ty*unity;
	float d = length(center-pos);
	if(d < best.z) // z used as distance
	{
		best.xy = center;
		best.z = d;
	}
}

void main()
{
	pos = surfacePosition;
	best = vec3(0.0, 0.0, 10000.0);

	int ch = int(mod(time*4.0, 46.));
	if(ch<26) ch += 65; // A
	else if(ch<36) ch += 48-26; // 0
	else if(ch==36) ch=63; // ?
	else if(ch==37) ch=33; // !
	else if(ch==38) ch=47; // /
	else if(ch==39) ch=37; // %
	else if(ch==40) ch=40; // (
	else if(ch==41) ch=41; // )
	else if(ch==42) ch=46; // .
	else if(ch==43) ch=58; // :
	else if(ch==44) ch=44; // ,
	else if(ch==45) ch=60; // <-

	if(ch==65) { // A
		closest_point(vec2(0.033, 0.329), vec2(-0.996, 0.087), -0.287, 0.000, 8.187);
		closest_point(vec2(0.033, 0.329), vec2(-0.996, 0.087), 0.000, 0.287, 8.187);
		closest_point(vec2(-0.323, 0.012), vec2(-0.297, -0.955), -0.124, -0.063, 33.184);
	}
	else if(ch==66) { // B
		closest_point(vec2(-0.118, 0.131), vec2(-0.143, 0.990), -0.433, 0.000, 1.018);
		closest_point(vec2(-0.118, 0.131), vec2(-0.143, 0.990), 0.000, 0.201, 1.018);
		closest_point(vec2(0.200, 0.318), vec2(-0.672, 0.740), -0.198, 0.000, 4.030);
		closest_point(vec2(0.200, 0.318), vec2(-0.672, 0.740), 0.000, 0.264, 4.030);
		closest_point(vec2(0.209, 0.054), vec2(0.563, 0.826), -0.211, 0.000, 4.998);
		closest_point(vec2(0.209, 0.054), vec2(0.563, 0.826), 0.000, 0.016, 4.998);
		closest_point(vec2(0.311, -0.259), vec2(0.397, 0.918), -0.280, 0.000, 6.176);
		closest_point(vec2(0.311, -0.259), vec2(0.397, 0.918), 0.000, 0.195, 6.176);
	}
	else if(ch==67) { // C
		closest_point(vec2(-0.137, 0.350), vec2(-0.854, -0.520), -0.288, 0.000, 2.927);
		closest_point(vec2(-0.137, 0.350), vec2(-0.854, -0.520), 0.000, 0.272, 2.927);
		closest_point(vec2(-0.124, -0.278), vec2(0.865, -0.502), -0.268, 0.000, 2.706);
		closest_point(vec2(-0.124, -0.278), vec2(0.865, -0.502), 0.000, 0.266, 2.706);
	}
	else if(ch==68) { // D
		closest_point(vec2(-0.114, -0.010), vec2(0.039, 0.999), -0.340, 0.000, 0.627);
		closest_point(vec2(-0.114, -0.010), vec2(0.039, 0.999), 0.000, 0.360, 0.627);
		closest_point(vec2(0.293, 0.282), vec2(-0.675, 0.738), -0.266, 0.000, 2.167);
		closest_point(vec2(0.293, 0.282), vec2(-0.675, 0.738), 0.000, 0.370, 2.167);
		closest_point(vec2(0.256, -0.245), vec2(0.709, 0.705), -0.396, 0.000, 1.600);
		closest_point(vec2(0.256, -0.245), vec2(0.709, 0.705), 0.000, 0.233, 1.600);
	}
	else if(ch==69) { // E
		closest_point(vec2(-0.067, 0.298), vec2(-0.854, -0.521), -0.248, 0.000, 2.205);
		closest_point(vec2(-0.067, 0.298), vec2(-0.854, -0.521), 0.000, 0.256, 2.205);
		closest_point(vec2(-0.163, -0.304), vec2(0.754, -0.657), -0.264, 0.000, 3.264);
		closest_point(vec2(-0.163, -0.304), vec2(0.754, -0.657), 0.000, 0.295, 3.264);
		closest_point(vec2(-0.198, 0.034), vec2(0.934, -0.356), -0.014, 0.000, 0.895);
		closest_point(vec2(-0.198, 0.034), vec2(0.934, -0.356), 0.000, 0.352, 0.895);
	}
	else if(ch==70) { // F
		closest_point(vec2(-0.095, 0.327), vec2(-0.789, -0.614), -0.263, 0.000, 3.324);
		closest_point(vec2(-0.095, 0.327), vec2(-0.789, -0.614), 0.000, 0.395, 3.324);
		closest_point(vec2(0.128, -0.000), vec2(0.998, -0.069), -0.300, 0.000, 0.779);
		closest_point(vec2(0.128, -0.000), vec2(0.998, -0.069), 0.000, 0.052, 0.779);
	}
	else if(ch==71) { // G
		closest_point(vec2(0.220, -0.115), vec2(-0.377, 0.926), -0.137, 0.000, 6.929);
		closest_point(vec2(0.220, -0.115), vec2(-0.377, 0.926), 0.000, 0.145, 6.929);
		closest_point(vec2(-0.072, -0.339), vec2(0.960, -0.278), -0.216, 0.000, 2.681);
		closest_point(vec2(-0.072, -0.339), vec2(0.960, -0.278), 0.000, 0.202, 2.681);
		closest_point(vec2(-0.259, 0.141), vec2(-0.418, -0.909), -0.212, 0.000, 1.949);
		closest_point(vec2(-0.259, 0.141), vec2(-0.418, -0.909), 0.000, 0.271, 1.949);
		closest_point(vec2(0.130, 0.317), vec2(-0.923, 0.385), -0.076, 0.000, 2.660);
		closest_point(vec2(0.130, 0.317), vec2(-0.923, 0.385), 0.000, 0.199, 2.660);
	}
	else if(ch==72) { // H
		closest_point(vec2(-0.219, 0.369), vec2(-0.279, 0.960), -0.682, -0.060, 0.445);
		closest_point(vec2(0.183, -0.355), vec2(0.376, -0.926), -0.626, -0.010, 0.727);
		closest_point(vec2(0.108, -0.054), vec2(-0.937, 0.349), -0.020, 0.000, 0.691);
		closest_point(vec2(0.108, -0.054), vec2(-0.937, 0.349), 0.000, 0.278, 0.691);
	}
	else if(ch==73) { // I
		closest_point(vec2(-0.695, -1.731), vec2(0.911, 0.412), 1.217, 1.517, 0.681);
		closest_point(vec2(-0.296, -0.349), vec2(-0.925, -0.381), -0.417, -0.143, 0.985);
		closest_point(vec2(-0.474, 0.485), vec2(0.543, -0.840), 0.333, 0.498, 2.004);
	}
	else if(ch==74) { // J
		closest_point(vec2(0.101, -0.304), vec2(0.862, 0.508), -0.240, 0.000, 3.599);
		closest_point(vec2(0.101, -0.304), vec2(0.862, 0.508), 0.000, 0.382, 3.599);
	}
	else if(ch==75) { // K
		closest_point(vec2(-0.108, 0.244), vec2(-0.186, 0.983), -0.558, 0.000, 0.637);
		closest_point(vec2(-0.108, 0.244), vec2(-0.186, 0.983), 0.000, 0.097, 0.637);
		closest_point(vec2(0.113, 0.029), vec2(-0.910, 0.414), -0.288, 0.000, 3.404);
		closest_point(vec2(0.113, 0.029), vec2(-0.910, 0.414), 0.000, 0.164, 3.404);
		closest_point(vec2(0.429, 0.339), vec2(-0.992, 0.124), 0.118, 0.308, 3.591);
	}
	else if(ch==76) { // L
		closest_point(vec2(0.329, -0.424), vec2(-0.742, 0.670), 0.125, 0.403, 1.442);
		closest_point(vec2(-0.150, 0.361), vec2(-0.828, 0.560), -0.402, -0.085, 3.451);
	}
	else if(ch==77) { // M
		closest_point(vec2(-0.228, 0.243), vec2(-0.943, -0.333), -0.158, 0.000, 14.229);
		closest_point(vec2(-0.228, 0.243), vec2(-0.943, -0.333), 0.000, 0.193, 14.229);
		closest_point(vec2(0.279, 0.248), vec2(-0.948, 0.319), -0.167, 0.000, 19.914);
		closest_point(vec2(0.279, 0.248), vec2(-0.948, 0.319), 0.000, 0.132, 19.914);
	}
	else if(ch==78) { // N
		closest_point(vec2(-0.448, -0.692), vec2(0.665, 0.747), 0.417, 0.955, 0.506);
		closest_point(vec2(0.166, -1.060), vec2(0.999, -0.037), 0.021, 0.029, 1697.797);
		closest_point(vec2(0.632, -2.436), vec2(0.095, 0.995), 2.056, 2.676, 0.146);
	}
	else if(ch==79) { // O
		closest_point(vec2(-0.222, 0.186), vec2(-0.633, -0.774), -0.196, 0.000, 3.462);
		closest_point(vec2(-0.222, 0.186), vec2(-0.633, -0.774), 0.000, 0.222, 3.462);
		closest_point(vec2(-0.036, -0.269), vec2(0.998, -0.069), -0.208, 0.000, 3.777);
		closest_point(vec2(-0.036, -0.269), vec2(0.998, -0.069), 0.000, 0.209, 3.777);
		closest_point(vec2(0.209, 0.117), vec2(-0.417, 0.909), -0.203, 0.000, 2.920);
		closest_point(vec2(0.209, 0.117), vec2(-0.417, 0.909), 0.000, 0.208, 2.920);
	}
	else if(ch==80) { // P
		closest_point(vec2(-0.269, 0.808), vec2(-0.735, 0.678), -0.856, -0.444, 1.100);
		closest_point(vec2(0.329, 0.164), vec2(-0.304, 0.953), -0.098, 0.000, 3.793);
		closest_point(vec2(0.329, 0.164), vec2(-0.304, 0.953), 0.000, 0.301, 3.793);
		closest_point(vec2(0.184, -0.081), vec2(0.956, 0.292), -0.247, 0.000, 3.046);
		closest_point(vec2(0.184, -0.081), vec2(0.956, 0.292), 0.000, 0.174, 3.046);
	}
	else if(ch==81) { // Q
		closest_point(vec2(-0.251, 0.112), vec2(-0.319, -0.948), -0.288, 0.000, 2.931);
		closest_point(vec2(-0.251, 0.112), vec2(-0.319, -0.948), 0.000, 0.271, 2.931);
		closest_point(vec2(0.265, 0.207), vec2(-0.519, 0.855), -0.287, 0.000, 3.197);
		closest_point(vec2(0.265, 0.207), vec2(-0.519, 0.855), 0.000, 0.184, 3.197);
		closest_point(vec2(0.034, -0.260), vec2(0.993, 0.119), -0.162, 0.000, 2.578);
		closest_point(vec2(0.034, -0.260), vec2(0.993, 0.119), 0.000, 0.162, 2.578);
		closest_point(vec2(-0.352, 0.200), vec2(-0.772, -0.636), -0.177, -0.143, 24.743);
	}
	else if(ch==82) { // R
		closest_point(vec2(-0.319, 1.159), vec2(-0.836, 0.549), -0.896, -0.631, 1.454);
		closest_point(vec2(0.283, 0.187), vec2(-0.261, 0.965), -0.186, 0.000, 6.038);
		closest_point(vec2(0.283, 0.187), vec2(-0.261, 0.965), 0.000, 0.237, 6.038);
		closest_point(vec2(0.232, -0.263), vec2(-0.248, 0.969), -0.063, 0.000, 2.079);
		closest_point(vec2(0.232, -0.263), vec2(-0.248, 0.969), 0.000, 0.375, 2.079);
	}
	else if(ch==83) { // S
		closest_point(vec2(-0.191, 0.155), vec2(0.314, -0.950), -0.090, 0.000, 5.310);
		closest_point(vec2(-0.191, 0.155), vec2(0.314, -0.950), 0.000, 0.146, 5.310);
		closest_point(vec2(0.220, -0.309), vec2(0.702, 0.713), -0.262, 0.000, 3.547);
		closest_point(vec2(0.220, -0.309), vec2(0.702, 0.713), 0.000, 0.150, 3.547);
		closest_point(vec2(0.260, -0.116), vec2(-0.345, 0.939), -0.031, 0.000, 3.288);
		closest_point(vec2(0.260, -0.116), vec2(-0.345, 0.939), 0.000, 0.260, 3.288);
		closest_point(vec2(-0.122, 0.313), vec2(-0.828, -0.561), -0.309, 0.000, 2.775);
		closest_point(vec2(-0.122, 0.313), vec2(-0.828, -0.561), 0.000, 0.080, 2.775);
	}
	else if(ch==84) { // T
		closest_point(vec2(0.852, 0.017), vec2(-0.857, 0.514), 0.621, 1.019, 0.343);
		closest_point(vec2(0.035, 0.177), vec2(-0.033, 0.999), -0.519, 0.000, 0.357);
		closest_point(vec2(0.035, 0.177), vec2(-0.033, 0.999), 0.000, 0.064, 0.357);
	}
	else if(ch==85) { // U
		closest_point(vec2(-0.132, -0.234), vec2(0.773, -0.634), -0.371, 0.000, 2.560);
		closest_point(vec2(-0.132, -0.234), vec2(0.773, -0.634), 0.000, 0.138, 2.560);
		closest_point(vec2(0.131, -0.256), vec2(0.861, 0.508), -0.121, 0.000, 2.742);
		closest_point(vec2(0.131, -0.256), vec2(0.861, 0.508), 0.000, 0.363, 2.742);
	}
	else if(ch==86) { // V
		closest_point(vec2(0.027, -0.281), vec2(1.000, 0.032), -0.236, 0.000, 9.164);
		closest_point(vec2(0.027, -0.281), vec2(1.000, 0.032), 0.000, 0.235, 9.164);
	}
	else if(ch==87) { // W
		closest_point(vec2(-0.127, -0.243), vec2(1.000, 0.006), -0.172, 0.000, 16.134);
		closest_point(vec2(-0.127, -0.243), vec2(1.000, 0.006), 0.000, 0.152, 16.134);
		closest_point(vec2(0.156, -0.255), vec2(1.000, 0.001), -0.132, 0.000, 22.245);
		closest_point(vec2(0.156, -0.255), vec2(1.000, 0.001), 0.000, 0.154, 22.245);
	}
	else if(ch==88) { // X
		closest_point(vec2(0.051, -0.001), vec2(0.999, 0.034), -0.230, 0.000, 4.287);
		closest_point(vec2(0.051, -0.001), vec2(0.999, 0.034), 0.000, 0.231, 4.287);
		closest_point(vec2(0.056, -0.003), vec2(-0.998, 0.062), -0.239, 0.000, 5.591);
		closest_point(vec2(0.056, -0.003), vec2(-0.998, 0.062), 0.000, 0.244, 5.591);
	}
	else if(ch==89) { // Y
		closest_point(vec2(0.048, 0.035), vec2(1.000, 0.015), -0.195, 0.000, 5.747);
		closest_point(vec2(0.048, 0.035), vec2(1.000, 0.015), 0.000, 0.196, 5.747);
		closest_point(vec2(0.062, -0.058), vec2(-0.034, 0.999), -0.294, 0.000, 1.293);
		closest_point(vec2(0.062, -0.058), vec2(-0.034, 0.999), 0.000, 0.093, 1.293);
	}
	else if(ch==90) { // Z
		closest_point(vec2(0.292, 0.232), vec2(-0.306, 0.952), -0.187, 0.000, 10.227);
		closest_point(vec2(0.292, 0.232), vec2(-0.306, 0.952), 0.000, 0.217, 10.227);
		closest_point(vec2(-0.222, -0.285), vec2(0.335, -0.942), -0.140, 0.000, 15.172);
		closest_point(vec2(-0.222, -0.285), vec2(0.335, -0.942), 0.000, 0.178, 15.172);
	}
	else if(ch==63) { // ?
		closest_point(vec2(0.039, 0.351), vec2(-0.903, 0.430), -0.122, 0.000, 3.746);
		closest_point(vec2(0.039, 0.351), vec2(-0.903, 0.430), 0.000, 0.228, 3.746);
		closest_point(vec2(0.100, 0.079), vec2(0.561, 0.828), -0.134, 0.000, 3.107);
		closest_point(vec2(0.100, 0.079), vec2(0.561, 0.828), 0.000, 0.155, 3.107);
		closest_point(vec2(-0.132, -0.067), vec2(-0.246, -0.969), -0.096, 0.000, 10.529);
		closest_point(vec2(-0.132, -0.067), vec2(-0.246, -0.969), 0.000, 0.078, 10.529);
		closest_point(vec2(-0.010, -0.365), vec2(-0.164, -0.986), -0.000, 0.000, 18753.586);
		closest_point(vec2(-0.010, -0.365), vec2(-0.164, -0.986), 0.000, 0.000, 18753.586);
	}
	else if(ch==33) { // !
		closest_point(vec2(-0.235, -0.528), vec2(0.765, 0.644), 0.471, 0.792, 0.740);
		closest_point(vec2(-0.019, -0.341), vec2(-0.966, 0.259), -0.010, 0.000, 138.332);
		closest_point(vec2(-0.019, -0.341), vec2(-0.966, 0.259), 0.000, 0.010, 138.332);
	}
	else if(ch==47) { // /
		closest_point(vec2(-0.554, -2.247), vec2(0.333, -0.943), -2.073, -1.703, 0.352);
	}
	else if(ch==37) { // %
		closest_point(vec2(0.709, 0.490), vec2(-0.999, -0.042), 0.518, 0.939, 0.902);
		closest_point(vec2(0.201, -0.144), vec2(-1.000, -0.008), -0.116, 0.000, 7.374);
		closest_point(vec2(0.201, -0.144), vec2(-1.000, -0.008), 0.000, 0.137, 7.374);
		closest_point(vec2(0.236, -0.342), vec2(0.938, 0.346), -0.143, 0.000, 5.564);
		closest_point(vec2(0.236, -0.342), vec2(0.938, 0.346), 0.000, 0.108, 5.564);
		closest_point(vec2(-0.240, 0.349), vec2(-0.998, -0.055), -0.128, 0.000, 6.175);
		closest_point(vec2(-0.240, 0.349), vec2(-0.998, -0.055), 0.000, 0.114, 6.175);
		closest_point(vec2(-0.239, 0.149), vec2(0.998, -0.063), -0.125, 0.000, 7.003);
		closest_point(vec2(-0.239, 0.149), vec2(0.998, -0.063), 0.000, 0.127, 7.003);
	}
	else if(ch==40) { // (
		closest_point(vec2(0.055, -0.053), vec2(0.064, -0.998), -0.327, 0.000, 1.346);
		closest_point(vec2(0.055, -0.053), vec2(0.064, -0.998), 0.000, 0.257, 1.346);
	}
	else if(ch==41) { // )
		closest_point(vec2(0.207, -0.020), vec2(0.009, 1.000), -0.323, 0.000, 1.959);
		closest_point(vec2(0.207, -0.020), vec2(0.009, 1.000), 0.000, 0.306, 1.959);
	}
	else if(ch==46) { // .
		closest_point(vec2(0.007, -0.369), vec2(0.581, -0.814), -0.002, 0.000, 2118.784);
		closest_point(vec2(0.007, -0.369), vec2(0.581, -0.814), 0.000, 0.002, 2118.784);
	}
	else if(ch==58) { // :
		closest_point(vec2(0.004, -0.277), vec2(0.857, -0.514), -0.003, 0.000, 713.712);
		closest_point(vec2(0.004, -0.277), vec2(0.857, -0.514), 0.000, 0.003, 713.712);
		closest_point(vec2(0.013, 0.108), vec2(-0.962, 0.275), -0.005, 0.000, 415.663);
		closest_point(vec2(0.013, 0.108), vec2(-0.962, 0.275), 0.000, 0.006, 415.663);
	}
	else if(ch==44) { // ,
		closest_point(vec2(0.102, -0.272), vec2(0.583, 0.813), -0.077, 0.000, 6.807);
		closest_point(vec2(0.102, -0.272), vec2(0.583, 0.813), 0.000, 0.044, 6.807);
	}
	else if(ch==48) { // 0
		closest_point(vec2(-0.065, 0.310), vec2(-0.964, -0.266), -0.227, 0.000, 4.417);
		closest_point(vec2(-0.065, 0.310), vec2(-0.964, -0.266), 0.000, 0.234, 4.417);
		closest_point(vec2(-0.075, -0.285), vec2(0.935, -0.356), -0.247, 0.000, 3.668);
		closest_point(vec2(-0.075, -0.285), vec2(0.935, -0.356), 0.000, 0.162, 3.668);
		closest_point(vec2(0.265, 0.022), vec2(-0.061, 0.998), -0.266, 0.000, 2.400);
		closest_point(vec2(0.265, 0.022), vec2(-0.061, 0.998), 0.000, 0.128, 2.400);
	}
	else if(ch==49) { // 1
		closest_point(vec2(0.141, 0.225), vec2(-0.730, 0.683), -0.043, 0.000, 24.616);
		closest_point(vec2(0.141, 0.225), vec2(-0.730, 0.683), 0.000, 0.092, 24.616);
		closest_point(vec2(-0.185, -0.355), vec2(-0.926, -0.377), -0.381, -0.109, 1.150);
		closest_point(vec2(0.143, 0.450), vec2(-0.050, 0.999), -0.770, -0.239, 0.189);
	}
	else if(ch==50) { // 2
		closest_point(vec2(0.019, 0.282), vec2(-1.000, -0.027), -0.131, 0.000, 3.021);
		closest_point(vec2(0.019, 0.282), vec2(-1.000, -0.027), 0.000, 0.205, 3.021);
		closest_point(vec2(0.189, 0.171), vec2(-0.276, 0.961), -0.336, 0.000, 4.109);
		closest_point(vec2(0.189, 0.171), vec2(-0.276, 0.961), 0.000, 0.068, 4.109);
		closest_point(vec2(0.455, -0.330), vec2(-0.014, 1.000), 0.037, 0.061, 168.443);
	}
	else if(ch==51) { // 3
		closest_point(vec2(0.051, 0.264), vec2(-0.990, 0.144), -0.174, 0.000, 3.743);
		closest_point(vec2(0.051, 0.264), vec2(-0.990, 0.144), 0.000, 0.181, 3.743);
		closest_point(vec2(0.041, -0.346), vec2(0.994, 0.106), -0.175, 0.000, 3.256);
		closest_point(vec2(0.041, -0.346), vec2(0.994, 0.106), 0.000, 0.171, 3.256);
		closest_point(vec2(0.201, -0.086), vec2(-0.560, 0.828), -0.125, 0.000, 5.354);
		closest_point(vec2(0.201, -0.086), vec2(-0.560, 0.828), 0.000, 0.181, 5.354);
		closest_point(vec2(0.174, -0.004), vec2(0.680, 0.734), -0.174, 0.000, 4.643);
		closest_point(vec2(0.174, -0.004), vec2(0.680, 0.734), 0.000, 0.118, 4.643);
	}
	else if(ch==52) { // 4
		closest_point(vec2(-0.108, 0.037), vec2(0.791, -0.612), -0.198, 0.000, 4.468);
		closest_point(vec2(-0.108, 0.037), vec2(0.791, -0.612), 0.000, 0.208, 4.468);
		closest_point(vec2(0.167, 0.434), vec2(-0.533, 0.846), -0.552, -0.133, 1.893);
	}
	else if(ch==53) { // 5
		closest_point(vec2(-0.116, 0.257), vec2(-0.748, -0.664), -0.214, 0.000, 4.705);
		closest_point(vec2(-0.116, 0.257), vec2(-0.748, -0.664), 0.000, 0.208, 4.705);
		closest_point(vec2(0.223, -0.124), vec2(-0.440, 0.898), -0.130, 0.000, 4.977);
		closest_point(vec2(0.223, -0.124), vec2(-0.440, 0.898), 0.000, 0.238, 4.977);
		closest_point(vec2(0.061, -0.356), vec2(0.998, 0.067), -0.183, 0.000, 3.060);
		closest_point(vec2(0.061, -0.356), vec2(0.998, 0.067), 0.000, 0.149, 3.060);
	}
	else if(ch==54) { // 6
		closest_point(vec2(0.287, -0.200), vec2(0.361, 0.933), -0.187, 0.000, 3.824);
		closest_point(vec2(0.287, -0.200), vec2(0.361, 0.933), 0.000, 0.106, 3.824);
		closest_point(vec2(-0.093, 0.266), vec2(-0.729, -0.684), -0.247, 0.000, 3.256);
		closest_point(vec2(-0.093, 0.266), vec2(-0.729, -0.684), 0.000, 0.218, 3.256);
		closest_point(vec2(0.001, -0.312), vec2(0.907, -0.420), -0.273, 0.000, 3.175);
		closest_point(vec2(0.001, -0.312), vec2(0.907, -0.420), 0.000, 0.091, 3.175);
		closest_point(vec2(0.130, 0.011), vec2(-0.999, 0.043), -0.157, 0.000, 3.505);
		closest_point(vec2(0.130, 0.011), vec2(-0.999, 0.043), 0.000, 0.209, 3.505);
	}
	else if(ch==55) { // 7
		closest_point(vec2(0.256, 0.220), vec2(-0.447, 0.895), -0.308, 0.000, 6.459);
		closest_point(vec2(0.256, 0.220), vec2(-0.447, 0.895), 0.000, 0.241, 6.459);
	}
	else if(ch==56) { // 8
		closest_point(vec2(-0.143, 0.257), vec2(-0.635, -0.773), -0.174, 0.000, 5.188);
		closest_point(vec2(-0.143, 0.257), vec2(-0.635, -0.773), 0.000, 0.138, 5.188);
		closest_point(vec2(0.252, 0.188), vec2(-0.248, 0.969), -0.266, 0.000, 6.568);
		closest_point(vec2(0.252, 0.188), vec2(-0.248, 0.969), 0.000, 0.143, 6.568);
		closest_point(vec2(0.234, -0.246), vec2(0.072, 0.997), -0.120, 0.000, 4.416);
		closest_point(vec2(0.234, -0.246), vec2(0.072, 0.997), 0.000, 0.305, 4.416);
		closest_point(vec2(-0.144, -0.295), vec2(0.429, -0.903), -0.094, 0.000, 6.700);
		closest_point(vec2(-0.144, -0.295), vec2(0.429, -0.903), 0.000, 0.194, 6.700);
	}
	else if(ch==57) { // 9
		closest_point(vec2(-0.119, 0.257), vec2(-0.787, -0.617), -0.165, 0.000, 5.379);
		closest_point(vec2(-0.119, 0.257), vec2(-0.787, -0.617), 0.000, 0.164, 5.379);
		closest_point(vec2(0.180, 0.213), vec2(-0.715, 0.700), -0.297, 0.000, 5.887);
		closest_point(vec2(0.180, 0.213), vec2(-0.715, 0.700), 0.000, 0.072, 5.887);
		closest_point(vec2(-0.069, -0.056), vec2(0.906, -0.424), -0.121, 0.000, 3.359);
		closest_point(vec2(-0.069, -0.056), vec2(0.906, -0.424), 0.000, 0.213, 3.359);
	}
	else if(ch==60) { // <
		closest_point(vec2(-0.292, 0.030), vec2(0.007, -1.000), -0.145, 0.000, 11.281);
		closest_point(vec2(-0.292, 0.030), vec2(0.007, -1.000), 0.000, 0.144, 11.281);
		closest_point(vec2(0.355, 0.019), vec2(0.000, 1.000), 0.005, 0.011, 5040.042);
	}

	vec3 pos3 = vec3(pos, 0.0);
	vec2 rad = pos3.xy - best.xy;
	float r = length(rad);
	float f = r * RF;
	vec3 color;
	if(f > 1.0)
		color = vec3(0.0, 0.0, 0.0); // background
	else
	{
		vec3 specular;
		float diffuse;
		float zc = sqrt(1.0 - f*f);
		vec3 norm = vec3(rad * f / r, zc);

		vec3 lightVector = LIGHTPOS - pos3;
		lightVector = normalize(lightVector);
		diffuse = max(0.0, dot(norm, lightVector)) + AMBIENT;

		vec3 cameraVector = vec3(0.0, 0.0, 1.0);

		vec3 halfVector = normalize(lightVector + cameraVector);
		float nxHalf = max(0.0,dot(norm, halfVector));
		float specularPower = pow(nxHalf, 40.0);
		specular = vec3(2.0) * specularPower;

		vec3 testpos = norm / RF + vec3(best.xy, 0.0);
		testpos = testpos * vec3(TSCALE, TSCALE, TSCALE);
		float tt = testpos.x + testpos.y + testpos.z;
		if(fract(tt+time*.3) < .5)
			color = COLOR2;
		else
			color = COLOR;
		color = diffuse * color + specular;
	}

	gl_FragColor =  vec4(color, 1.0);
}
